"""
ARCHIVED ANT TELEMETRY SECTIONS FROM live_dashboard.py
Archived on 2026-02-10 as part of comprehensive telemetry redesign.

This file contains two sections:
1. 3D Ant Swarm Telemetry (lines 924-1091) - plots E-H
2. Ant Telemetry Panel (lines 1537-1895) - Terminal/Charts tabs

These sections are being temporarily archived to make room for a unified,
comprehensive telemetry view that exposes ALL training state in a compact,
machine + human readable format.

To restore: Copy relevant sections back to live_dashboard.py and uncomment.
"""

# ============================================================
# SECTION 1: 3D Ant Swarm Telemetry (E-H plots)
# Lines 924-1091 from original dashboard
# ============================================================

'''
                    # ── Ant Swarm Telemetry Row (E-H) ─────────────
                    # Detect how many ant columns exist
                    _ant_acc_cols = sorted(
                        [c for c in surf_df.columns if c.startswith("ant_") and c.endswith("_acc")])
                    _ant_route_cols = sorted(
                        [c for c in surf_df.columns if c.startswith("ant_") and c.endswith("_route")])
                    _has_ant_ent = "ant_ent" in surf_df.columns and surf_df["ant_ent"].notna().any()
                    _has_ant_active = "ant_active" in surf_df.columns and surf_df["ant_active"].notna().any()

                    if len(_ant_acc_cols) > 1:
                        stmod6.markdown("---")
                        stmod6.markdown(
                            "**Ant Swarm Telemetry** — per-expert routing visualization  "
                            "*(rotate E to side view along ant_id axis for coherence waveform)*")

                        _n_ants_vis = len(_ant_acc_cols)
                        _ant_ids = list(range(_n_ants_vis))
                        cam_ant_side = {"eye": {"x": 2.5, "y": 0.1, "z": 0.8}}

                        sE, sF, sG, sH = stmod6.columns(4)

                        # ── E: Per-Ant Accuracy Surface ───────────
                        with sE:
                            z_e = []
                            for _ai in range(_n_ants_vis):
                                col = f"ant_{_ai}_acc"
                                z_e.append(surf_df[col].fillna(0.0).values.tolist())
                            fig_e = pltgo6x.Figure(data=[pltgo6x.Surface(
                                x=step_arr.tolist(),
                                y=_ant_ids,
                                z=z_e,
                                colorscale=_cs_vrx,
                                reversescale=True,
                                showscale=False,
                                opacity=0.92,
                            )])
                            fig_e.update_layout(
                                title="E: Ant Accuracy Swarm",
                                scene={
                                    "xaxis": {"title": "Step"},
                                    "yaxis": {"title": "Ant ID"},
                                    "zaxis": {"title": "Accuracy"},
                                    "bgcolor": "rgba(0,0,0,0)",
                                },
                                scene_camera=cam_ant_side,
                                margin=_surf_margin,
                                height=380,
                                paper_bgcolor="rgba(0,0,0,0)",
                                plot_bgcolor="rgba(0,0,0,0)",
                            )
                            stmod6.plotly_chart(fig_e,
                                                width="stretch")

                        # ── F: Per-Ant Routing Distribution ───────
                        with sF:
                            if len(_ant_route_cols) > 1:
                                z_f = []
                                for _ai in range(_n_ants_vis):
                                    col = f"ant_{_ai}_route"
                                    if col in surf_df.columns:
                                        z_f.append(surf_df[col].fillna(0.0).values.tolist())
                                    else:
                                        z_f.append([0.0] * len(surf_df))
                                # Normalize to routing share per step
                                import numpy as _np_ant
                                z_f_arr = _np_ant.array(z_f, dtype=float)
                                row_sums = z_f_arr.sum(axis=0, keepdims=True)
                                row_sums = _np_ant.where(row_sums > 0, row_sums, 1.0)
                                z_f_share = (z_f_arr / row_sums).tolist()
                                fig_f = pltgo6x.Figure(data=[pltgo6x.Surface(
                                    x=step_arr.tolist(),
                                    y=_ant_ids,
                                    z=z_f_share,
                                    colorscale=_cs_vrx,
                                    showscale=False,
                                    opacity=0.92,
                                )])
                                fig_f.update_layout(
                                    title="F: Ant Routing Share",
                                    scene={
                                        "xaxis": {"title": "Step"},
                                        "yaxis": {"title": "Ant ID"},
                                        "zaxis": {"title": "Share"},
                                        "bgcolor": "rgba(0,0,0,0)",
                                    },
                                    scene_camera=cam_ant_side,
                                    margin=_surf_margin,
                                    height=380,
                                    paper_bgcolor="rgba(0,0,0,0)",
                                    plot_bgcolor="rgba(0,0,0,0)",
                                )
                                stmod6.plotly_chart(fig_f,
                                                    width="stretch")
                            else:
                                stmod6.caption(
                                    "F: Routing data not available yet.")

                        # ── G: Routing Entropy Trace ──────────────
                        with sG:
                            if _has_ant_ent:
                                _ent_df = surf_df[["step", "ant_ent"]].dropna()
                                fig_g = pltgo6x.Figure()
                                fig_g.add_trace(pltgo6x.Scatter3d(
                                    x=_ent_df["step"].values.tolist(),
                                    y=[_n_ants_vis / 2.0] * len(_ent_df),
                                    z=_ent_df["ant_ent"].values.tolist(),
                                    mode="lines",
                                    name="Routing entropy",
                                    line={"color": "#ffeb3b", "width": 4},
                                ))
                                fig_g.update_layout(
                                    title="G: Routing Entropy",
                                    scene={
                                        "xaxis": {"title": "Step"},
                                        "yaxis": {"title": "Ant ID"},
                                        "zaxis": {"title": "Entropy",
                                                   "range": [0, 1]},
                                        "bgcolor": "rgba(0,0,0,0)",
                                    },
                                    scene_camera=cam_ant_side,
                                    margin=_surf_margin,
                                    height=380,
                                    paper_bgcolor="rgba(0,0,0,0)",
                                    plot_bgcolor="rgba(0,0,0,0)",
                                )
                                stmod6.plotly_chart(fig_g,
                                                    width="stretch")
                            else:
                                stmod6.caption(
                                    "G: Entropy data not available yet.")

                        # ── H: Active Ant Count ───────────────────
                        with sH:
                            if _has_ant_active:
                                _act_df = surf_df[["step", "ant_active"]].dropna()
                                fig_h = pltgo6x.Figure()
                                fig_h.add_trace(pltgo6x.Scatter3d(
                                    x=_act_df["step"].values.tolist(),
                                    y=[0] * len(_act_df),
                                    z=_act_df["ant_active"].values.tolist(),
                                    mode="lines",
                                    name="Active ants",
                                    line={"color": "#00ff00", "width": 4},
                                ))
                                fig_h.update_layout(
                                    title="H: Active Ant Count",
                                    scene={
                                        "xaxis": {"title": "Step"},
                                        "yaxis": {"title": "Ant ID"},
                                        "zaxis": {"title": "Count",
                                                   "range": [0, _n_ants_vis]},
                                        "bgcolor": "rgba(0,0,0,0)",
                                    },
                                    scene_camera=cam_ant_side,
                                    margin=_surf_margin,
                                    height=380,
                                    paper_bgcolor="rgba(0,0,0,0)",
                                    plot_bgcolor="rgba(0,0,0,0)",
                                )
                                stmod6.plotly_chart(fig_h,
                                                    width="stretch")
                            else:
                                stmod6.caption(
                                    "H: Active count data not available yet.")
                    else:
                        stmod6.caption(
                            "Single-expert mode — ant swarm telemetry "
                            "requires VRX_EXPERT_HEADS > 1")
'''

# ============================================================
# SECTION 2: Ant Telemetry Panel (Terminal + Charts tabs)
# Lines 1537-1895 from original dashboard
# ============================================================

'''
    # ── Ant telemetry panel (probe JSONL) ──────────────────────────────────
    ant_telem_path = str(logpth).replace(".log", "_ant_telemetry.jsonl")
    ant_rows = _read_jsonl_tail(ant_telem_path, max_lines=5000)
    if ant_rows:
        with stmod6.expander("Ant Swarm Telemetry", expanded=True):
            # Discover ant count from first row with ants.
            n_ants_telem = 0
            for row in ant_rows:
                if "ants" in row and isinstance(row["ants"], list):
                    n_ants_telem = len(row["ants"])
                    break

            if n_ants_telem > 0:
                # Build per-ant time series (shared by both tabs).
                ant_series = {f"ant{i}_{k}": [] for i in range(n_ants_telem)
                              for k in ["gnorm", "xor", "slow", "fast", "rvar",
                                        "r_xor", "r_slow", "r_fast"]}
                ant_series["step"] = []
                ant_series["acc"] = []
                ant_series["loss"] = []
                ant_series["r_combined_xor"] = []

                for row in ant_rows:
                    ants = row.get("ants")
                    if not ants or len(ants) != n_ants_telem:
                        continue
                    ant_series["step"].append(int(row.get("step", 0)))
                    ant_series["acc"].append(float(row.get("acc", 0.0)))
                    ant_series["loss"].append(float(row.get("loss", 0.0)))
                    rolling = row.get("rolling") or {}
                    ant_series["r_combined_xor"].append(
                        float(rolling.get("combined_xor", 0.0)))
                    for i, ad in enumerate(ants):
                        for k in ["gnorm", "xor", "slow", "fast", "rvar"]:
                            ant_series[f"ant{i}_{k}"].append(float(ad.get(k, 0.0)))
                        for k in ["r_xor", "r_slow", "r_fast"]:
                            ant_series[f"ant{i}_{k}"].append(float(ad.get(k, 0.0)))

                if not ant_series["step"]:
                    stmod6.caption("No ant data rows parsed yet.")
                else:
                    adf = pd.DataFrame(ant_series)

                    # Ring sizes for labels (used by both tabs).
                    ring_labels = []
                    for row in ant_rows:
                        if "ants" in row and isinstance(row["ants"], list):
                            ring_labels = [f"ant{i} (ring={a.get('ring', '?')})"
                                           for i, a in enumerate(row["ants"])]
                            break

                    # Detect active vs frozen ants: an ant is active if its
                    # gnorm was ever > 0 in the last 20 rows.
                    active_ants = set()
                    for row in ant_rows[-20:]:
                        ants = row.get("ants") or []
                        for i, ad in enumerate(ants):
                            if float(ad.get("gnorm", 0.0)) > 0.0:
                                active_ants.add(i)
                    has_staged = len(active_ants) < n_ants_telem

                    # Staged training banner.
                    if has_staged:
                        def _ring_tag(idx):
                            if idx < len(ring_labels):
                                parts = ring_labels[idx].split("=")
                                return parts[1].rstrip(")") if len(parts) > 1 else "?"
                            return "?"
                        active_list = ", ".join(
                            f"ant[{i}] (ring={_ring_tag(i)})"
                            for i in sorted(active_ants))
                        frozen_count = n_ants_telem - len(active_ants)
                        stmod6.info(
                            f"**Staged training:** {len(active_ants)} active, "
                            f"{frozen_count} frozen  |  Active: {active_list}")

                    # ── TABS ──────────────────────────────────────────────
                    tab_term, tab_charts = stmod6.tabs(["Terminal", "Charts"])

                    # ════════════════════════════════════════════════════════
                    # TAB 1: Terminal (default) — monospace text output
                    # ════════════════════════════════════════════════════════
                    with tab_term:
                        term_lines_n = int(stmod6.slider(
                            "Tail lines", min_value=10, max_value=200,
                            value=40, step=10, key="term_tail"))

                        # Build terminal text from the last N rows.
                        tail_rows = ant_rows[-term_lines_n:]
                        term_lines = []
                        for row in tail_rows:
                            ants = row.get("ants")
                            if not ants or len(ants) != n_ants_telem:
                                continue
                            s = int(row.get("step", 0))
                            lo = row.get("loss", 0.0)
                            ac = row.get("acc", 0.0)
                            spd = row.get("s_per_step", 0.0)
                            hdr = (f"step {s:>5d} | loss {lo:.4f} | "
                                   f"acc {ac:.3f} | {spd:.2f} s/step")
                            term_lines.append(hdr)

                            for i, ad in enumerate(ants):
                                is_frozen = has_staged and i not in active_ants
                                if is_frozen:
                                    continue  # Skip frozen ants in terminal
                                ring = ad.get("ring", "?")
                                gn = ad.get("gnorm", 0.0)
                                vt = ad.get("vote", -1)
                                xr = ad.get("xor", 0.0)
                                sl = ad.get("slow", 0.0)
                                ft = ad.get("fast", 0.0)
                                rv = ad.get("rvar", 0.0)
                                tag = " *" if i in active_ants and has_staged else ""
                                aline = (f"  ant[{i}] ring={str(ring):>4s}"
                                         f"  gnorm={gn:>7.3f}"
                                         f"  vote={vt}"
                                         f"  xor={xr:.3f}"
                                         f"  slow={sl:.3f}"
                                         f"  fast={ft:.3f}"
                                         f"  rvar={rv:.4f}{tag}")
                                # Append rolling if present.
                                r_xor = ad.get("r_xor")
                                if r_xor is not None:
                                    r_sl = ad.get("r_slow", 0.0)
                                    r_ft = ad.get("r_fast", 0.0)
                                    aline += (f"  | R: xor={r_xor:.3f}"
                                              f" slow={r_sl:.3f}"
                                              f" fast={r_ft:.3f}")
                                term_lines.append(aline)

                            # Rolling combined line.
                            rl = row.get("rolling")
                            if rl:
                                n_win = rl.get("n", 0)
                                rc_xor = rl.get("combined_xor", 0.0)
                                term_lines.append(
                                    f"  rolling (n={n_win}): "
                                    f"combined_xor={rc_xor:.4f}")
                            term_lines.append("")  # blank separator

                        terminal_text = "\\n".join(term_lines)
                        stmod6.code(terminal_text, language=None)

                    # ════════════════════════════════════════════════════════
                    # TAB 2: Charts — all plotly graphs
                    # ════════════════════════════════════════════════════════
                    with tab_charts:
                        smooth_w = int(stmod6.slider(
                            "Smoothing window (MA)",
                            min_value=1, max_value=200, value=25, step=5,
                            key="ant_smooth_w"))

                        pltgo_mod = _opt_mod("plotly.graph_objects")
                        if pltgo_mod is not None:
                            # Cyan (big ring, slow) → Magenta (small ring, fast)
                            # Darker for bigger ants, brighter for smaller ants
                            def _ant_colors(n):
                                if n <= 1:
                                    return ["#ff00ff"]
                                out = []
                                for i in range(n):
                                    t = i / max(1, n - 1)  # 0=biggest ring, 1=smallest
                                    # Cyan dark → Cyan bright → Magenta bright
                                    if t < 0.5:
                                        # Dark cyan to bright cyan
                                        s = t * 2  # 0→1
                                        r = int(0 + s * 30)
                                        g = int(80 + s * 175)
                                        b = int(120 + s * 135)
                                    else:
                                        # Bright cyan to bright magenta
                                        s = (t - 0.5) * 2  # 0→1
                                        r = int(30 + s * 225)
                                        g = int(255 - s * 205)
                                        b = int(255 - s * 50)
                                    out.append(f"#{r:02x}{g:02x}{b:02x}")
                                return out
                            colors = _ant_colors(n_ants_telem)

                            def _add_smoothed(fig, x_col, y_col, label, color,
                                              window, frozen=False):
                                if frozen:
                                    # Frozen ants: very faint, thin, no raw trace.
                                    smoothed = adf[y_col].rolling(
                                        window=window, min_periods=1).mean()
                                    fig.add_trace(pltgo_mod.Scatter(
                                        x=adf[x_col], y=smoothed,
                                        name=label + " (frozen)", mode="lines",
                                        line={"color": "#555555", "width": 1,
                                              "dash": "dot"},
                                        opacity=0.2, showlegend=False))
                                    return
                                fig.add_trace(pltgo_mod.Scatter(
                                    x=adf[x_col], y=adf[y_col],
                                    name=label + " raw", mode="lines",
                                    line={"color": color, "width": 1},
                                    opacity=0.15, showlegend=False))
                                smoothed = adf[y_col].rolling(
                                    window=window, min_periods=1).mean()
                                fig.add_trace(pltgo_mod.Scatter(
                                    x=adf[x_col], y=smoothed,
                                    name=label, mode="lines",
                                    line={"color": color, "width": 3}))

                            # 1. Gradient norm (skip frozen — they're always 0).
                            fig_gnorm = pltgo_mod.Figure()
                            for i in range(n_ants_telem):
                                if has_staged and i not in active_ants:
                                    continue  # Don't even draw flat-zero lines
                                lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                _add_smoothed(fig_gnorm, "step", f"ant{i}_gnorm",
                                              lbl, colors[i % len(colors)], smooth_w)
                            fig_gnorm.update_layout(
                                title=f"Per-Ant Gradient Norm (MA {smooth_w})"
                                      + (" — active only" if has_staged else ""),
                                xaxis_title="Step", yaxis_title="Grad Norm",
                                legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                margin={"l": 50, "r": 20, "t": 50, "b": 40})
                            stmod6.plotly_chart(fig_gnorm, width="stretch")

                            # 2. SLOW / FAST side by side.
                            c_slow, c_fast = stmod6.columns(2)
                            with c_slow:
                                fig_slow = pltgo_mod.Figure()
                                for i in range(n_ants_telem):
                                    lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                    is_frozen = has_staged and i not in active_ants
                                    _add_smoothed(fig_slow, "step", f"ant{i}_slow",
                                                  lbl, colors[i % len(colors)], smooth_w,
                                                  frozen=is_frozen)
                                fig_slow.add_hline(y=0.5, line_dash="dot",
                                                   line_color="gray", opacity=0.5)
                                fig_slow.update_layout(
                                    title=f"SLOW component (MA {smooth_w})",
                                    xaxis_title="Step", yaxis_title="Acc (slow)",
                                    yaxis_range=[0, 1],
                                    legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                    margin={"l": 50, "r": 20, "t": 50, "b": 40})
                                stmod6.plotly_chart(fig_slow, width="stretch")

                            with c_fast:
                                fig_fast = pltgo_mod.Figure()
                                for i in range(n_ants_telem):
                                    lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                    is_frozen = has_staged and i not in active_ants
                                    _add_smoothed(fig_fast, "step", f"ant{i}_fast",
                                                  lbl, colors[i % len(colors)], smooth_w,
                                                  frozen=is_frozen)
                                fig_fast.add_hline(y=0.5, line_dash="dot",
                                                   line_color="gray", opacity=0.5)
                                fig_fast.update_layout(
                                    title=f"FAST component (MA {smooth_w})",
                                    xaxis_title="Step", yaxis_title="Acc (fast)",
                                    yaxis_range=[0, 1],
                                    legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                    margin={"l": 50, "r": 20, "t": 50, "b": 40})
                                stmod6.plotly_chart(fig_fast, width="stretch")

                            # 3. XOR combined.
                            fig_xor = pltgo_mod.Figure()
                            for i in range(n_ants_telem):
                                lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                is_frozen = has_staged and i not in active_ants
                                _add_smoothed(fig_xor, "step", f"ant{i}_xor",
                                              lbl, colors[i % len(colors)], smooth_w,
                                              frozen=is_frozen)
                            fig_xor.add_hline(y=0.5, line_dash="dot",
                                              line_color="gray", opacity=0.5)
                            fig_xor.update_layout(
                                title=f"XOR combined (MA {smooth_w})",
                                xaxis_title="Step", yaxis_title="Acc (XOR)",
                                yaxis_range=[0, 1],
                                legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                margin={"l": 50, "r": 20, "t": 50, "b": 40})
                            stmod6.plotly_chart(fig_xor, width="stretch")

                            # 4. Rolling accuracy (clean lines).
                            has_rolling = any(
                                v != 0.0 for v in adf.get("r_combined_xor", []))
                            if has_rolling:
                                stmod6.markdown("---")
                                stmod6.markdown(
                                    "**Rolling Accuracy** (1600-sample window) "
                                    "-- no smoothing needed, the buffer IS the filter")

                                fig_rcomb = pltgo_mod.Figure()
                                fig_rcomb.add_trace(pltgo_mod.Scatter(
                                    x=adf["step"], y=adf["r_combined_xor"],
                                    name="Combined XOR", mode="lines",
                                    line={"color": "#e879f9", "width": 3}))
                                fig_rcomb.add_hline(y=0.5, line_dash="dot",
                                                    line_color="gray", opacity=0.5)
                                fig_rcomb.update_layout(
                                    title="Combined Rolling XOR Accuracy",
                                    xaxis_title="Step", yaxis_title="Accuracy",
                                    yaxis_range=[0, 1],
                                    margin={"l": 50, "r": 20, "t": 50, "b": 40})
                                stmod6.plotly_chart(fig_rcomb, width="stretch")

                                rc_slow, rc_fast = stmod6.columns(2)
                                with rc_slow:
                                    fig_rslow = pltgo_mod.Figure()
                                    for i in range(n_ants_telem):
                                        lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                        fig_rslow.add_trace(pltgo_mod.Scatter(
                                            x=adf["step"], y=adf[f"ant{i}_r_slow"],
                                            name=lbl, mode="lines",
                                            line={"color": colors[i % len(colors)], "width": 2}))
                                    fig_rslow.add_hline(y=0.5, line_dash="dot",
                                                        line_color="gray", opacity=0.5)
                                    fig_rslow.update_layout(
                                        title="Rolling SLOW (per-ant)",
                                        xaxis_title="Step", yaxis_title="Acc (slow)",
                                        yaxis_range=[0, 1],
                                        legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                        margin={"l": 50, "r": 20, "t": 50, "b": 40})
                                    stmod6.plotly_chart(fig_rslow, width="stretch")

                                with rc_fast:
                                    fig_rfast = pltgo_mod.Figure()
                                    for i in range(n_ants_telem):
                                        lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                        fig_rfast.add_trace(pltgo_mod.Scatter(
                                            x=adf["step"], y=adf[f"ant{i}_r_fast"],
                                            name=lbl, mode="lines",
                                            line={"color": colors[i % len(colors)], "width": 2}))
                                    fig_rfast.add_hline(y=0.5, line_dash="dot",
                                                        line_color="gray", opacity=0.5)
                                    fig_rfast.update_layout(
                                        title="Rolling FAST (per-ant)",
                                        xaxis_title="Step", yaxis_title="Acc (fast)",
                                        yaxis_range=[0, 1],
                                        legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                        margin={"l": 50, "r": 20, "t": 50, "b": 40})
                                    stmod6.plotly_chart(fig_rfast, width="stretch")

                                fig_rxor = pltgo_mod.Figure()
                                for i in range(n_ants_telem):
                                    lbl = ring_labels[i] if i < len(ring_labels) else f"ant{i}"
                                    fig_rxor.add_trace(pltgo_mod.Scatter(
                                        x=adf["step"], y=adf[f"ant{i}_r_xor"],
                                        name=lbl, mode="lines",
                                        line={"color": colors[i % len(colors)], "width": 2}))
                                fig_rxor.add_hline(y=0.5, line_dash="dot",
                                                   line_color="gray", opacity=0.5)
                                fig_rxor.update_layout(
                                    title="Rolling XOR (per-ant)",
                                    xaxis_title="Step", yaxis_title="Acc (XOR)",
                                    yaxis_range=[0, 1],
                                    legend={"orientation": "h", "y": 1.02, "x": 0.01},
                                    margin={"l": 50, "r": 20, "t": 50, "b": 40})
                                stmod6.plotly_chart(fig_rxor, width="stretch")

                            pass  # 3D mesh removed; surfaces are below main loss chart
                        else:
                            stmod6.caption("Plotly not available for ant charts.")
    else:
        stmod6.caption(f"No ant telemetry found at: {ant_telem_path}")
'''
